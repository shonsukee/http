# HTTP/1.1
## HTTP/1.0との差分
- 通信の高速化
    - Keep-Aliveがデフォルトで有効に
- プロトコルをアップグレード可能に
- 1台のサーバで複数のアプリケーションを運用できる
- TLSによる暗号化通信のサポート
- PUT, DELETE等メソッドの追加
- プロトコルのアップデート
- チャンク送信エンコーディングのサポート




## Keep-Aliveによる通信の高速化
- EtagやCache-Controlなどのキャッシュ機能はリソースごとに通信を最適化(HTTP/1.1で追加)
- Keep-Aliveは全てのHTTP通信を高速化

- 今まで
    - 一つのリクエストごとに通信を閉じる
- Keep-Alive導入後
    - 連続したリクエスト時に接続を再利用
    - 接続までの待ち時間が減り，スループットが向上する
    - オープン・クローズ時に複数回の通信が発生してしまうため，それを予防できる
    - モバイルではバッテリーの無駄も減る

### クローズするタイミングは？
- サーバ側が全ての通信終了を判断することはできない
- また，JSなどがあるためクライアント側でも全ての通信完了を検知できない
- Keep-Aliveの持続時間はクライアントとサーバの両方が持っていて短い方が採用される


## プロトコルのアップグレード
- HTTP/1.1からはHTTP以外のプロトコルにアップグレードできる
- この申請はクライアント側からもサーバ側からもできる

1. HTTP→TLSへの安全な通信へアップグレード
2. HTTP→WebSocketを使った双方向通信へのアップグレード
3. HTTP→HTTP/2へのアップグレード



### クライアント側からの要請
- Upgrade, Connectionヘッダフィールドを送ることでアップグレードできる
- 特にTLSへのアップグレード要求時にサーバが対応していなければ非暗号化のままレスポンスが来る可能性がある
- そのためクライアント→サーバへOPTIONSリクエストを送ってアップグレードを要求する

### サーバ側からの要請
- 426レスポンスが送られる
- しかし，再度クライアントから要請されてアップグレードされる



## バーチャルホストのサポート
- HTTP/1.0までは１台のウェブサーバで一つのドメインのみを扱う前提だった
- HTTP/1.1からはHostヘッダフィールドにリクエストを送りたいサーバ名を指定することで，同じサーバの同じポートでも運用できる


## チャンク
- HTTP/1.1ではチャンクという小さなデータに分割する方法によってリードタイムを短くできるようになった
- HTTP/2.0ではチャンク分割は廃止された
- HTTP/3ではフレーム分割が導入された




## TLS(Transport Layer Security)
- リクエストされたオリジンと，実際にアクセス先のサーバが同じことを確認する仕組み

### プロセス
1. Client Helloメッセージ
    - クライアントがサポートするTLSバージョン
    - 対応する暗号スイート
    - クライアントランダムというランダムなバイト文字列
2. Server Helloメッセージ
    - サーバのSSL証明書
    - 選んだ暗号スイート
    - サーバランダムというランダムなバイト文字列
3. 認証
    - 取得したSSL証明書から公開鍵を入手可能
    - クライアントはサーバのSSL証明書を，中間CA証明書に含まれる公開鍵で検証
    - このようにある証明書を，上位の証明書に含まれる公開鍵で検証することをデジタル署名という
4. プリマスタシークレット
    - クライアントがランダムなバイト文字列を生成して公開鍵で暗号化を行い，サーバへ送信
5. 秘密鍵でプリマスタシークレットを復号
6. セッション鍵を生成
    - 「クライアントランダム + サーバランダム + プリマスタシークレット」からセッション鍵を生成
    - クライアントとサーバは同じ鍵を持つことになる
7. クライアントの準備完了
8. サーバの準備完了
9. セキュアな対称暗号化の実現


### TLS 1.3 ハンドシェイク
1. Client Helloメッセージ
    - 対応する暗号スイート(TLS1.3では攻撃されやすい暗号スイートを非対応に)
    - 鍵共有パラメータ
2. サーバのマスタシークレット
    - クライアントの鍵共有パラメータを持っているためマスタシークレットを生成できる
3. Server Helloメッセージと「完了」
    - サーバの証明書，デジタル署名，鍵共有パラメータ，選択した暗号スイートを一括送信！
    - セッション鍵も生成済みなので完了メッセージも送る！
4. クライアントの準備完了
    - 署名と証明書を検証
    - マスタシークレットを生成
5. セキュアな対称暗号化の実現


### TLS 1.3の0-RTTモード
- Round Trip Time(往復の通信)なしで接続再開できる

#### 仕組み
1. セッション終了時，サーバがセッション再開用のチケット(暗号スイートやパラメータが暗号化したもの)を渡す
    - このチケットはサーバで検証するため，クライアントはチケットの復号方法を知らなくて良い
2. クライアントはこのチケットをClient Helloに添付して送ると，サーバはそのチケットを復号して再開できる


### TLSの高速化



## XMLHttpRequest
- curlコマンドをJSから送れるようにするもの
- 今まではアプリケーションをインストールして，電子メールを送る必要があった
- しかし，動的に情報を取得して，ブラウザ上で完結させたいという考えから生まれた

- これをつかうとJSの中で送受信が完結するため画面がクリアされることなく最新情報をサーバから取得できる
- 画面クリアせずウェブページを読み込んだり時間やタイミングをずらして何度も更新できるなど，JavaScriptを使って非同期通信を行うアーキテクチャをAjaxという
- 今まで(ブラウザ上でHTTPリクエスト)
    - ユーザ → Webブラウザ → Webサーバ
    - ページ遷移が入り，DOMを再構築する必要があった
- Ajax
    - ユーザ → JavaScript(Webブラウザ上) → Webサーバ
    - 非同期通信を行うための技術的手法のこと
    - XMLという名前が入っているが，考え方なのでJSONでもOK

- Node.jsとの違いは[こちら](https://qiita.com/non_cal/items/a8fee0b7ad96e67713eb)から確認
    - `/NODE.md`に簡単にまとめた


- ポーリングやロングポーリングによって双方向通信もどきを作れた
- HTTP/2.0以降ではWebSocketなどが考え出されているため現在使われていない


## RPC
- 別のコンピュータにある情報を，あたかも自分のコンピュータ内にあるかのように呼び出して情報を受け取る仕組み

### XML-RPC
- メソッドはPOSTで呼び出しの引数，返り値ともにXMLで表現
- Content-Typeは常にtext/xml
- RPCだけど通信内容が常にplain textなので特別なツールを使わなくても読める

### SOAP
- XML-RPCの拡張版
- SOAPエンベロープの中にSOAPヘッダ，SOAPボディがある
- ヘッダにはリクエストメソッドやトランザクション情報，ボディにはデータが入る
- 可搬性を重視するあまり複雑度が高まって使いにくくなった

- データ構造を記述するときに，データの仕様(XMLスキーマを)用意する必要があり大変
- 複数の言語を触らないといけなくて大変

