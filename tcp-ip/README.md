# TCP/IPの実装
- TCP/IPプロトコルをGolangで実装する
- 参考記事は[こちら](https://zenn.dev/satoken/articles/golang-tcpip)

## 目的
- TCP/IPという概念について学び，実際の通信で行われている流れを掴む
- どこでエラーが起きているのか判断する力や曖昧な理解を解消するために実施する
- macOSのため一部ライブラリの利用を検討するが，できる限り実装する


## TCP/IP階層別の名称とプロトコル
- 基本情報の参考は[こちら](https://www.itmanage.co.jp/column/tcp-ip-protocol/)


| 層  | 名称   | 規格（プロトコル）    | 主な利用例  |
|-----|-------|--------------------|-----------|
| 4層 | アプリケーション層    | HTTP, HTTPS, SMTP, POP3, IMAP4, DHCP, DNSなど   | Webサイト閲覧、メール、ファイル転送など             |
| 3層 | トランスポート層      | TCP, UDP, NetWare/IPなど                        | TCP/UDP（データを適切なアプリケーションへ振り分け）  |
| 2層 | インターネット層      | IP, ARP, RARP, ICMPなど                         | ルーティング、エンドツーエンド通信                 |
| 1層 | ネットワークインタフェース層 | Ethernet                                  | LAN                                         |

### 自分の解釈
4層. アプリケーションで扱うデータのフォーマットや手順を決める役割．クライアント・サーバ間の通信を開始するレイヤ．通信方法は抽象化されていて，気にしなくてもいい

3層. データを適切なアプリケーションに振り分ける．送信元と宛先のアプリ間でデータの送受信ができる．データに求めるのが正確性か，スピードでかわる

2層. 複数のネットワーク間のデータ転送を行う役割．パケットに分割するIPが主流．同一ネットワーク内でルータ間を移動する．ルーティングが使われる．

1層. 同一のネットワーク内でデータを転送すること．有線のEthernetや無線のWifiなどが使われて物理的に転送される．

### OSI参照モデルの階層との違い
| OSI参照モデル           | TCP/IP階層モデル             |
|------------------------|-----------------------------|
| 7層 アプリケーション層  | 4層 アプリケーション層        |
| 6層 プレゼンテーション層| 4層 アプリケーション層      |
| 5層 セッション層        | 4層 アプリケーション層      |
| 4層 トランスポート層    | 3層 トランスポート層          |
| 3層 ネットワーク層      | 2層 インターネット層          |
| 2層 データリンク層      | 1層 ネットワークインタフェース層 |
| 1層 物理層              | 1層 ネットワークインタフェース層 |



## Ethernet: `ethernet.go`
まずは1層目のネットワークインタフェース層を実装する．

> [!NOTE]
> 目的: コンピュータ同士をネットワークで接続しデータ通信を行うこと

## IP
続いて2層目のインターネット層を実装する．
ARPを実装する．


### ARP: `arp.go`

> [!NOTE]
> 目的: IPアドレスからMacアドレスを取得すること

IPアドレスとMacアドレスの対応付けをしておき，検索するためのプロトコル

どのネットワークインターフェース（例: 有線LAN, 無線LAN）からパケットを送るかを決め，その情報（MACアドレスなど）を取得する

```sh
# Wifi/有線LANのインタフェース名
$ networksetup -listallhardwareports
# ex:)
# Hardware Port: Wi-Fi
# Device: en0
# Ethernet Address: aa:aa:aa:aa:aa:aa

# inetが実行環境のIPアドレス，サブネット
$ ifconfig en0

# 宛先IPアドレスにping送信
$ ping -c 3 192.168.1.1

# ここで，tcp-ip/main.go内の宛先IPアドレスを変更！

# main.goに宛先IPアドレスを指定して実行
$ cd tcp-ip && sudo go run main.go
```

**流れ**
1. 宛先IPアドレスを用意
2. Ethernetのインタフェース情報を取得
3. その情報からIPアドレスを取得
4. 宛先Macアドレスは不明なのでブロードキャストするようなパケット作成
5. パケットをバイト列に変換
6. ARPリクエスト送信
7. 帰ってきたARPリプライを取得

> [!TIP]
> 参考記事ではLinux環境でのコードを記述していた．
> 私の環境であるMacではsyscallを使用できないため`google/gopacket`モジュールで一部を抽象化している．

## UDP
次は3層目のトランスポート層を実装する．
UDP/TCPを実装する．

> [!NOTE]
> 目的: アプリケーション間のデータを転送すること

### 実際の通信フロー
#### 送信時の処理
1. アプリケーションが「Hello UDP!」等のメッセージを送信
2. UDP層がポート番号を付加
3. IP層がIPアドレスとルーティング情報を付加
4. Ethernet層がMACアドレスを付加
5. 物理層でビット列として送信

#### 受信時の処理
1. 物理層でビット列を受信
2. Ethernet層でMACアドレスを確認
3. IP層でIPアドレスとプロトコルを確認
4. UDP層でポート番号を確認
5. アプリケーションにデータを渡す

> [!TIP]
> Wiresharkを使用して`udp.port == 49152`でフィルタリングすると通信を確認できる

## TCP

**3Way-Handshake**
1. クライアント→サーバ: データを転送していいですか？(SYN)
2. サーバ→クライアント: OK!(ACK) 私もデータを転送していい？(SYN)
3. クライアント→サーバ: OK!(ACK)


### 実際の通信フロー
1. クライアントがSYNパケットを作成
2. TCP接続を作成
3. 送信元，宛先のIPアドレスとMacアドレスを取得して初期化
4. SYN用のTCPヘッダを作成
5. pcapを用いてTCPパケットを送信
6. サーバは受け取ったTCPパケットに対する通信許可を出すためのACKと，クライアントに対する通信許可を求めるSYNを一緒に送信
7. シーケンス番号とACK番号を更新してACKパケットを送信
8. 接続完了！

`tcp.go`はsyscallパッケージが使えないためエラーが発生する．
- 1回目のSYN, 2回目のSYN+ACKは正しく送受信できる
- しかし，クライアントのOSが，ユーザー空間から送信されたSYNに対するSYN+ACKの返答を「不審なもの」として扱い、RST（リセット）を返す
- そのため実装できてはいそうだが，3way-handshakeを最後まで実装できてはいない
- Linuxならできるため今後の展望とする
